<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>ListsCommands - scredis.commands.async.ListsCommands</title>
          <meta name="description" content="ListsCommands - scredis.commands.async.ListsCommands" />
          <meta name="keywords" content="ListsCommands scredis.commands.async.ListsCommands" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'scredis.commands.async.ListsCommands';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/trait_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="scredis">scredis</a>.<a href="../package.html" class="extype" name="scredis.commands">commands</a>.<a href="package.html" class="extype" name="scredis.commands.async">async</a></p>
        <h1>ListsCommands</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">ListsCommands</span><span class="result"> extends <span class="extype" name="scredis.commands.async.Async">Async</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>This trait implements asynchronous lists commands.</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scredis.commands.async.Async">Async</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a href="../../PipelineClient.html" class="extype" name="scredis.PipelineClient">PipelineClient</a>, <a href="../../Redis.html" class="extype" name="scredis.Redis">Redis</a>, <a href="../../TransactionalClient.html" class="extype" name="scredis.TransactionalClient">TransactionalClient</a></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="scredis.commands.async.ListsCommands"><span>ListsCommands</span></li><li class="in" name="scredis.commands.async.Async"><span>Async</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        <div id="values" class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="scredis.commands.async.Async#DefaultCommandOptions" visbl="prt" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="DefaultCommandOptions:scredis.CommandOptions"></a>
      <a id="DefaultCommandOptions:CommandOptions"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">DefaultCommandOptions</span><span class="result">: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>Async</dd></dl></div>
    </li><li name="scredis.commands.async.Async#async" visbl="prt" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="async[A](body:scredis.Client=&gt;A)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="async[A]((Client)⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">async</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="body">body: (<a href="../../Client.html" class="extype" name="scredis.Client">Client</a>) ⇒ <span class="extype" name="scredis.commands.async.Async.async.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.Async.async.A">A</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>Async</dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Concrete Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lIndex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lIndex[A](key:String,index:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="lIndex[A](String,Long)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lIndex</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="index">index: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="../../parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.lIndex.A">A</span>] = <span class="symbol"><span class="name"><a href="../../package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.lIndex.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an element from a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an element from a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>zero-based position in the list</p></dd><dt>returns</dt><dd class="cmt"><p>the requested element, or <code>None</code> when index is out of range</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The index is zero-based, so 0 means the first element, 1 the second element and so on.
Negative indices can be used to designate elements starting at the tail of the list.
Here, -1 means the last element, -2 means the penultimate and so forth.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lInsert" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lInsert(key:String,pivot:String,value:Any,after:Boolean)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="lInsert(String,String,Any,Boolean)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lInsert</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="pivot">pivot: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="after">after: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts an element before or after another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element before or after another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt class="param">after</dt><dd class="cmt"><p>when true, inserts the element after the pivot, when false the element is inserted
before the pivot (default is true, i.e. after)</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lInsertAfter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lInsertAfter(key:String,pivot:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="lInsertAfter(String,String,Any)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lInsertAfter</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="pivot">pivot: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts an element after another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element after another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lInsertBefore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lInsertBefore(key:String,pivot:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="lInsertBefore(String,String,Any)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lInsertBefore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="pivot">pivot: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts an element before another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element before another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lLen(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lLen(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lLen</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the length of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list at key, or 0 if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPop[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="lPop[A](String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPop</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="../../parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.lPop.A">A</span>] = <span class="symbol"><span class="name"><a href="../../package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.lPop.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes and returns the first element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the first element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPush(key:String,value:Any,values:Any*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lPush(String,Any,Any*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPush</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="values">values: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Prepends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt class="param">values</dt><dd class="cmt"><p>additional values to prepend (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lPushX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPushX(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lPushX(String,Any)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPushX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Prepends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lRange[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[List[A]]"></a>
      <a id="lRange[A](String,Long,Long)(CommandOptions,Parser[A]):Future[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lRange</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="../../parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.lRange.A">A</span>] = <span class="symbol"><span class="name"><a href="../../package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scredis.commands.async.ListsCommands.lRange.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of elements from a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of elements from a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>list of elements in the specified range, or the empty list if there are no such
elements or if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The offsets start and end are zero-based indexes, with 0 being the first element of the
list (the head of the list), 1 being the next element and so on. These offsets can also be
negative numbers indicating offsets starting at the end of the list. For example, -1 is the
last element of the list, -2 the penultimate, and so on. Both offsets are inclusive, i.e.
LRANGE key 0 10 will return 11 elements (if they exist).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lRem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lRem(key:String,value:Any,count:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lRem(String,Any,Long)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lRem</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="count">count: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes the first count occurrences of elements equal to value from the list stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the first count occurrences of elements equal to value from the list stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be removed from the list</p></dd><dt class="param">count</dt><dd class="cmt"><p>indicates the number of found values that should be removed, see above note</p></dd><dt>returns</dt><dd class="cmt"><p>the number of removed elements</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The count argument influences the operation in the following ways:</p><pre>count &gt; <span class="num">0</span>: Remove elements equal to value moving from head to tail.
count &lt; <span class="num">0</span>: Remove elements equal to value moving from tail to head.
count = <span class="num">0</span>: Remove all elements equal to value.</pre></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lSet(key:String,index:Long,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="lSet(String,Long,Any)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lSet</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="index">index: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the value of an element in a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of an element in a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>position of the element to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be set at index</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if index is out of range or if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lTrim" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lTrim(key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="lTrim(String,Long,Long)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lTrim</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Trims a list to the specified range.</p><div class="fullcomment"><div class="comment cmt"><p>Trims a list to the specified range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Out of range indexes will not produce an error: if start is larger than the end of the
list, or start &gt; end, the result will be an empty list (which causes key to be removed). If
end is larger than the end of the list, Redis will treat it like the last element of the list.
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPop[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="rPop[A](String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPop</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="../../parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.rPop.A">A</span>] = <span class="symbol"><span class="name"><a href="../../package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.rPop.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes and returns the last element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the last element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPopLPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPopLPush[A](sourceKey:String,destKey:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="rPopLPush[A](String,String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPopLPush</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sourceKey">sourceKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="../../parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.rPopLPush.A">A</span>] = <span class="symbol"><span class="name"><a href="../../package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.rPopLPush.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes the last element in a list, appends it to another list and returns it.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the last element in a list, appends it to another list and returns it.
</p></div><dl class="paramcmts block"><dt class="param">sourceKey</dt><dd class="cmt"><p>key of list to be pop from</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key of list to be push to</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPush(key:String,value:Any,values:Any*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="rPush(String,Any,Any*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPush</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="values">values: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Appends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Appends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt class="param">values</dt><dd class="cmt"><p>additional values to prepend (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPushX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPushX(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="rPushX(String,Any)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPushX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="../../CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Appends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"> <dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scredis.commands.async.Async">
              <h3>Inherited from <span class="extype" name="scredis.commands.async.Async">Async</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../lib/template.js"></script>
    </body>
      </html>