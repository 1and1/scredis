<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>PipelineClient - scredis.PipelineClient</title>
          <meta name="description" content="PipelineClient - scredis.PipelineClient" />
          <meta name="keywords" content="PipelineClient scredis.PipelineClient" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../index.html';
            var hash = 'scredis.PipelineClient';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../lib/class_big.png" />
        <p id="owner"><a href="package.html" class="extype" name="scredis">scredis</a></p>
        <h1>PipelineClient</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">PipelineClient</span><span class="result"> extends <a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a> with <a href="commands/async/ConnectionCommands.html" class="extype" name="scredis.commands.async.ConnectionCommands">ConnectionCommands</a> with <a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a> with <a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a> with <a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a> with <a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a> with <a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a> with <a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a> with <a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a> with <a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a> with <a href="commands/async/PubSubCommands.html" class="extype" name="scredis.commands.async.PubSubCommands">PubSubCommands</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Represents a client that queues command before pipelining them all as part of a
single request.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="commands/async/PubSubCommands.html" class="extype" name="scredis.commands.async.PubSubCommands">PubSubCommands</a>, <a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a>, <a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a>, <a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a>, <a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a>, <a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a>, <a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a>, <a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a>, <a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a>, <a href="commands/async/ConnectionCommands.html" class="extype" name="scredis.commands.async.ConnectionCommands">ConnectionCommands</a>, <span class="extype" name="scredis.commands.async.Async">Async</span>, <a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="scredis.PipelineClient"><span>PipelineClient</span></li><li class="in" name="scredis.commands.async.PubSubCommands"><span>PubSubCommands</span></li><li class="in" name="scredis.commands.async.ScriptingCommands"><span>ScriptingCommands</span></li><li class="in" name="scredis.commands.async.SortedSetsCommands"><span>SortedSetsCommands</span></li><li class="in" name="scredis.commands.async.SetsCommands"><span>SetsCommands</span></li><li class="in" name="scredis.commands.async.ListsCommands"><span>ListsCommands</span></li><li class="in" name="scredis.commands.async.HashesCommands"><span>HashesCommands</span></li><li class="in" name="scredis.commands.async.StringsCommands"><span>StringsCommands</span></li><li class="in" name="scredis.commands.async.KeysCommands"><span>KeysCommands</span></li><li class="in" name="scredis.commands.async.ServerCommands"><span>ServerCommands</span></li><li class="in" name="scredis.commands.async.ConnectionCommands"><span>ConnectionCommands</span></li><li class="in" name="scredis.commands.async.Async"><span>Async</span></li><li class="in" name="scredis.QueuingClient"><span>QueuingClient</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="scredis.QueuingClient.Command" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Command=(Seq[Array[Byte]],(Char,Array[Byte])=&gt;Any)"></a>
      <a id="Command:(Seq[Array[Byte]],(Char,Array[Byte])⇒Any)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Command</span><span class="result"> = (<span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]], (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scala.Any">Any</span>)</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scredis.QueuingClient#DefaultCommandOptions" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DefaultCommandOptions:scredis.CommandOptions"></a>
      <a id="DefaultCommandOptions:CommandOptions"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">DefaultCommandOptions</span><span class="result">: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#append" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="append(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="append(String,Any)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">append</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Appends a value to a key.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a value to a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to be appended</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value to append</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string after the append operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scredis.QueuingClient#async" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="async[A](body:scredis.Client=&gt;A)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="async[A]((Client)⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">async</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="body">body: (<a href="Client.html" class="extype" name="scredis.Client">Client</a>) ⇒ <span class="extype" name="scredis.QueuingClient.async.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.QueuingClient.async.A">A</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scredis.commands.async.ConnectionCommands#auth" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="auth(password:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="auth(String)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">auth</span><span class="params">(<span name="password">password: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Authenticates to the server.</p><div class="fullcomment"><div class="comment cmt"><p>Authenticates to the server.
</p></div><dl class="paramcmts block"><dt class="param">password</dt><dd class="cmt"><p>the server password</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ConnectionCommands.html" class="extype" name="scredis.commands.async.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if authentication failed
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#bgRewriteAOF" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bgRewriteAOF()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="bgRewriteAOF()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bgRewriteAOF</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronously rewrites the append-only file.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously rewrites the append-only file.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#bgSave" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bgSave()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="bgSave()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bgSave</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Asynchronously saves the dataset to disk.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronously saves the dataset to disk.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the background save is already in progress
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#bitCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitCount(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="bitCount(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitCount</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Counts the number of bits set to 1 in a string.</p><div class="fullcomment"><div class="comment cmt"><p>Counts the number of bits set to 1 in a string.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key for which the bitcount should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>the number of bits set to 1</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Non-existent keys are treated as empty strings, so the command will return zero.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#bitCountInRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitCountInRange(key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="bitCountInRange(String,Long,Long)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitCountInRange</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Counts the number of bits set to 1 in a string from start offset to end offset.</p><div class="fullcomment"><div class="comment cmt"><p>Counts the number of bits set to 1 in a string from start offset to end offset.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key for which the bitcount should be returned</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset in bytes</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset in bytes</p></dd><dt>returns</dt><dd class="cmt"><p>the number of bits set to 1 in the specified interval</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Non-existent keys are treated as empty strings, so the command will return zero.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#bitOpAnd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitOpAnd(key1:String,key2:String,destKey:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="bitOpAnd(String,String,String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitOpAnd</span><span class="params">(<span name="key1">key1: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="key2">key2: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs bitwise AND operation between two strings.</p><div class="fullcomment"><div class="comment cmt"><p>Performs bitwise AND operation between two strings.
</p></div><dl class="paramcmts block"><dt class="param">key1</dt><dd class="cmt"><p>left operand</p></dd><dt class="param">key2</dt><dd class="cmt"><p>right operand</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key where the result of the operation will be stored</p></dd><dt>returns</dt><dd class="cmt"><p>the size of the string stored in the destination key, that is equal to the size of
the longest input string</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When an operation is performed between strings having different lengths, all the strings
shorter than the longest string in the set are treated as if they were zero-padded up to the
length of the longest string. The same holds true for non-existent keys, that are considered
as a stream of zero bytes up to the length of the longest string.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#bitOpNot" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitOpNot(key:String,destKey:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="bitOpNot(String,String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitOpNot</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs bitwise NOT operation on a given string.</p><div class="fullcomment"><div class="comment cmt"><p>Performs bitwise NOT operation on a given string.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the source key</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key where the result of the operation will be stored</p></dd><dt>returns</dt><dd class="cmt"><p>the size of the string stored in the destination key, that is equal to the size of
the longest input string</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#bitOpOr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitOpOr(key1:String,key2:String,destKey:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="bitOpOr(String,String,String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitOpOr</span><span class="params">(<span name="key1">key1: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="key2">key2: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs bitwise OR operation between two strings.</p><div class="fullcomment"><div class="comment cmt"><p>Performs bitwise OR operation between two strings.
</p></div><dl class="paramcmts block"><dt class="param">key1</dt><dd class="cmt"><p>left operand</p></dd><dt class="param">key2</dt><dd class="cmt"><p>right operand</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key where the result of the operation will be stored</p></dd><dt>returns</dt><dd class="cmt"><p>the size of the string stored in the destination key, that is equal to the size of
the longest input string</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When an operation is performed between strings having different lengths, all the strings
shorter than the longest string in the set are treated as if they were zero-padded up to the
length of the longest string. The same holds true for non-existent keys, that are considered
as a stream of zero bytes up to the length of the longest string.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#bitOpXor" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bitOpXor(key1:String,key2:String,destKey:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="bitOpXor(String,String,String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bitOpXor</span><span class="params">(<span name="key1">key1: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="key2">key2: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs bitwise XOR operation between two strings.</p><div class="fullcomment"><div class="comment cmt"><p>Performs bitwise XOR operation between two strings.
</p></div><dl class="paramcmts block"><dt class="param">key1</dt><dd class="cmt"><p>left operand</p></dd><dt class="param">key2</dt><dd class="cmt"><p>right operand</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key where the result of the operation will be stored</p></dd><dt>returns</dt><dd class="cmt"><p>the size of the string stored in the destination key, that is equal to the size of
the longest input string</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When an operation is performed between strings having different lengths, all the strings
shorter than the longest string in the set are treated as if they were zero-padded up to the
length of the longest string. The same holds true for non-existent keys, that are considered
as a stream of zero bytes up to the length of the longest string.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#clientGetName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientGetName()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[String]]"></a>
      <a id="clientGetName()(CommandOptions):Future[Option[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientGetName</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Get the current client name.</p><div class="fullcomment"><div class="comment cmt"><p>Get the current client name.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>option containing the name if it has been set, <code>None</code> otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.9
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#clientKill" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientKill(addr:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="clientKill(String)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientKill</span><span class="params">(<span name="addr">addr: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Kills the connection of a client.</p><div class="fullcomment"><div class="comment cmt"><p>Kills the connection of a client.
</p></div><dl class="paramcmts block"><dt class="param">addr</dt><dd class="cmt"><p>string containing ip and port separated by colon, i.e. &quot;ip:port&quot;</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">RedisCommandException<p>if the the client does not exist
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#clientKillFromIpPort" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientKillFromIpPort(ip:String,port:Int)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="clientKillFromIpPort(String,Int)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientKillFromIpPort</span><span class="params">(<span name="ip">ip: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="port">port: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Kills the connection of a client.</p><div class="fullcomment"><div class="comment cmt"><p>Kills the connection of a client.
</p></div><dl class="paramcmts block"><dt class="param">ip</dt><dd class="cmt"><p>ip address of the target client</p></dd><dt class="param">port</dt><dd class="cmt"><p>port of the target client</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">RedisCommandException<p>if the the client does not exist
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#clientList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientList()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[List[Map[String,String]]]"></a>
      <a id="clientList()(CommandOptions):Future[List[Map[String,String]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientList</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets the list of client connections.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the list of client connections.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>list of clients
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#clientListRaw" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientListRaw()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[String]"></a>
      <a id="clientListRaw()(CommandOptions):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientListRaw</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets the list of client connections.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the list of client connections.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>raw string containing the list of clients as returned by Redis
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#clientSetName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clientSetName(name:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="clientSetName(String)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clientSetName</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the current client name.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the current client name. If the empty string is provided, the name will be unset.
</p></div><dl class="paramcmts block"><dt class="param">name</dt><dd class="cmt"><p>name to associate the client to, if empty, unsets the client name
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.9
</p></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scredis.QueuingClient#completeWithException" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="completeWithException(e:Throwable):Unit"></a>
      <a id="completeWithException(Throwable):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">completeWithException</span><span class="params">(<span name="e">e: <span class="extype" name="scala.Throwable">Throwable</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#configGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="configGet(pattern:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Map[String,Option[String]]]]"></a>
      <a id="configGet(String)(CommandOptions):Future[Option[Map[String,Option[String]]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">configGet</span><span class="params">(<span name="pattern">pattern: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;*&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets the value of a configuration parameter.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the value of a configuration parameter.
</p></div><dl class="paramcmts block"><dt class="param">pattern</dt><dd class="cmt"><p>name or pattern of the configuration parameter to get</p></dd><dt>returns</dt><dd class="cmt"><p>option containing the matched parameters, or <code>None</code> if no parameters are matched
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#configResetStat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="configResetStat()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="configResetStat()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">configResetStat</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resets the stats returned by INFO.</p><div class="fullcomment"><div class="comment cmt"><p>Resets the stats returned by INFO.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#configSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="configSet(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="configSet(String,Any)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">configSet</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets a configuration parameter to the given value.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a configuration parameter to the given value.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>parameter's name</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set parameter to</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the parameter could not be set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#dbSize" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dbSize()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="dbSize()(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dbSize</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return the number of keys in the selected database.</p><div class="fullcomment"><div class="comment cmt"><p>Return the number of keys in the selected database.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>number of keys in the selected database
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#decr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="decr(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="decr(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">decr</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Decrements the integer value of a key by one.</p><div class="fullcomment"><div class="comment cmt"><p>Decrements the integer value of a key by one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to decrement</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type or contains a string that cannot be
represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#decrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="decrBy(key:String,count:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="decrBy(String,Long)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">decrBy</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Decrements the integer value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Decrements the integer value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to decrement</p></dd><dt class="param">count</dt><dd class="cmt"><p>the decrement</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type or contains
a string that cannot be represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#del" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="del(key:String,keys:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="del(String,String*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">del</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Deletes one or multiple keys.</p><div class="fullcomment"><div class="comment cmt"><p>Deletes one or multiple keys.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to delete</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys to delete</p></dd><dt>returns</dt><dd class="cmt"><p>the number of keys that were deleted
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>a key is ignored if it does not exist
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#dump" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dump(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Array[Byte]]]"></a>
      <a id="dump(String)(CommandOptions):Future[Option[Array[Byte]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">dump</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a serialized version of the value stored at the specified key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a serialized version of the value stored at the specified key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to dump</p></dd><dt>returns</dt><dd class="cmt"><p>the serialized value or <code>None</code> if the key does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ConnectionCommands#echo" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="echo(message:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[String]"></a>
      <a id="echo(String)(CommandOptions):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">echo</span><span class="params">(<span name="message">message: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Echoes the given string on the server.</p><div class="fullcomment"><div class="comment cmt"><p>Echoes the given string on the server.
</p></div><dl class="paramcmts block"><dt class="param">message</dt><dd class="cmt"><p>the message to echo</p></dd><dt>returns</dt><dd class="cmt"><p>the echoed message
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ConnectionCommands.html" class="extype" name="scredis.commands.async.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#eval" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eval[A](script:String)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="eval[A](String)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eval</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="script">script: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.eval.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.eval.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a Lua script that does not require any keys or arguments.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a Lua script that does not require any keys or arguments.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>set key</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if an error occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#evalSha" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalSha[A](sha1:String)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="evalSha[A](String)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalSha</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sha1">sha1: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.evalSha.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.evalSha.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a cached Lua script that does not require any keys or arguments by its SHA1 digest.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a cached Lua script that does not require any keys or arguments by its SHA1 digest.
</p></div><dl class="paramcmts block"><dt class="param">sha1</dt><dd class="cmt"><p>the SHA1 digest</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if there is no script corresponding to the provided SHA1 digest or if an error
occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#evalShaWithArgs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalShaWithArgs[A](sha1:String)(args:Any*)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="evalShaWithArgs[A](String)(Any*)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalShaWithArgs</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sha1">sha1: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.evalShaWithArgs.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.evalShaWithArgs.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a cached Lua script with arguments by its SHA1 digest.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a cached Lua script with arguments by its SHA1 digest.
</p></div><dl class="paramcmts block"><dt class="param">sha1</dt><dd class="cmt"><p>the SHA1 digest</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if there is no script corresponding to the provided SHA1 digest or if an error
occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#evalShaWithKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalShaWithKeys[A](sha1:String)(keys:String*)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="evalShaWithKeys[A](String)(String*)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalShaWithKeys</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sha1">sha1: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.evalShaWithKeys.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.evalShaWithKeys.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a cached Lua script with keys parameter by its SHA1 digest.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a cached Lua script with keys parameter by its SHA1 digest.
</p></div><dl class="paramcmts block"><dt class="param">sha1</dt><dd class="cmt"><p>the SHA1 digest</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if there is no script corresponding to the provided SHA1 digest or if an error
occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#evalShaWithKeysAndArgs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalShaWithKeysAndArgs[A](sha1:String)(keys:String*)(args:Any*)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="evalShaWithKeysAndArgs[A](String)(String*)(Any*)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalShaWithKeysAndArgs</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sha1">sha1: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.evalShaWithKeysAndArgs.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.evalShaWithKeysAndArgs.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a cached Lua script with keys and arguments by its SHA1 digest.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a cached Lua script with keys and arguments by its SHA1 digest.
</p></div><dl class="paramcmts block"><dt class="param">sha1</dt><dd class="cmt"><p>the SHA1 digest</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if there is no script corresponding to the provided SHA1 digest or if an error
occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#evalWithArgs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalWithArgs[A](script:String)(args:Any*)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="evalWithArgs[A](String)(Any*)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalWithArgs</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="script">script: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.evalWithArgs.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.evalWithArgs.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a Lua script with arguments.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a Lua script with arguments.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>set key</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if an error occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#evalWithKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalWithKeys[A](script:String)(keys:String*)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="evalWithKeys[A](String)(String*)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalWithKeys</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="script">script: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.evalWithKeys.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.evalWithKeys.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a Lua script with keys parameter.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a Lua script with keys parameter.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>set key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if an error occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#evalWithKeysAndArgs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalWithKeysAndArgs[A](script:String)(keys:String*)(args:Any*)(as:scredis.protocol.As=&gt;((Char,Array[Byte])=&gt;A))(implicitopts:scredis.CommandOptions):scala.concurrent.Future[A]"></a>
      <a id="evalWithKeysAndArgs[A](String)(String*)(Any*)((As)⇒(Char,Array[Byte])⇒A)(CommandOptions):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalWithKeysAndArgs</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="script">script: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span name="args">args: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span name="as">as: (<span class="extype" name="scredis.protocol.As">As</span>) ⇒ (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scredis.commands.async.ScriptingCommands.evalWithKeysAndArgs.A">A</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.ScriptingCommands.evalWithKeysAndArgs.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes a Lua script with keys and arguments.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a Lua script with keys and arguments.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>set key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys to be used in the script</p></dd><dt class="param">args</dt><dd class="cmt"><p>arguments to be used in the script</p></dd><dt class="param">as</dt><dd class="cmt"><p>result handler</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if an error occurs while running the script</p></span><span class="cmt">[[scredis.exceptions.RedisProtocolException]]<p>if the value returned by the script does not match with the result handler
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#exists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="exists(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="exists(String)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exists</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Determines if a key exists.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a key exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to check for existence</p></dd><dt>returns</dt><dd class="cmt"><p>true if the key exists, false otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#expire" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expire(key:String,ttlSeconds:Int)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="expire(String,Int)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expire</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="ttlSeconds">ttlSeconds: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets a key's time to live in seconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a key's time to live in seconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">ttlSeconds</dt><dd class="cmt"><p>time-to-live in seconds</p></dd><dt>returns</dt><dd class="cmt"><p>true if the ttl was set, false if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#expireAt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expireAt(key:String,timestamp:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="expireAt(String,Long)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expireAt</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="timestamp">timestamp: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the expiration for a key as a UNIX timestamp.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the expiration for a key as a UNIX timestamp.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">timestamp</dt><dd class="cmt"><p>UNIX timestamp at which the key should expire</p></dd><dt>returns</dt><dd class="cmt"><p>true if the ttl was set, false if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#expireFromDuration" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="expireFromDuration(key:String,ttl:scala.concurrent.duration.FiniteDuration)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="expireFromDuration(String,FiniteDuration)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">expireFromDuration</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="ttl">ttl: <span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets a key's time to live.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a key's time to live.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">ttl</dt><dd class="cmt"><p>duration after which the key should expire</p></dd><dt>returns</dt><dd class="cmt"><p>true if the ttl was set, false if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#flushAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flushAll()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="flushAll()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flushAll</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes all keys from all databases.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all keys from all databases.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#flushDb" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flushDb()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="flushDb()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flushDb</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes all keys from the current database.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all keys from the current database.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#get" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="get[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="get[A](String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">get</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.StringsCommands.get.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.StringsCommands.get.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt>returns</dt><dd class="cmt"><p>value stored at key, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#getBit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getBit(key:String,offset:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="getBit(String,Long)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getBit</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the bit value at offset in the string value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the bit value at offset in the string value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">offset</dt><dd class="cmt"><p>the position in the string</p></dd><dt>returns</dt><dd class="cmt"><p>true if the bit is set to 1, false otherwise</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#getRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getRange[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[A]"></a>
      <a id="getRange[A](String,Long,Long)(CommandOptions,Parser[A]):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getRange</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.StringsCommands.getRange.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.StringsCommands.getRange.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a substring of the string stored at a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a substring of the string stored at a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">start</dt><dd class="cmt"><p>the start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>the end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the substring determined by the specified offsets</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.4.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both offsets are inclusive, i.e. [start, end]. The function handles out of range
requests by limiting the resulting range to the actual length of the string.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#getSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getSet[A](key:String,value:Any)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="getSet[A](String,Any)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getSet</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.StringsCommands.getSet.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.StringsCommands.getSet.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the string value of a key and return its old value.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a key and return its old value.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">value</dt><dd class="cmt"><p>the value to set key to</p></dd><dt>returns</dt><dd class="cmt"><p>the old value, or <code>None</code> if the latter did not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hDel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hDel(key:String)(field:String,fields:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="hDel(String)(String,String*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hDel</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fields">fields: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Deletes one or more hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Deletes one or more hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of the hash</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to be deleted from hash</p></dd><dt class="param">fields</dt><dd class="cmt"><p>additional fields to be deleted (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of fields that were removed from the hash, not including specified but non
existing fields</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Specified fields that do not exist within this hash are ignored. If key does not exist,
it is treated as an empty hash and this command returns 0. Redis versions older than 2.4 can
only remove a field per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hExists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hExists(key:String)(field:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="hExists(String)(String)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hExists</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Determines if a hash field exists.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a hash field exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>name of the field</p></dd><dt>returns</dt><dd class="cmt"><p>true if the hash contains field, false if the hash does not contain it or the key does
not exists</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hGet[A](key:String)(field:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="hGet[A](String)(String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hGet</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.HashesCommands.hGet.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.HashesCommands.hGet.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the value of a hash field.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the value of a hash field.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>the value associated with field name, or <code>None</code> when field is not present in the hash
or key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hGetAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hGetAll[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[Map[String,A]]]"></a>
      <a id="hGetAll[A](String)(CommandOptions,Parser[A]):Future[Option[Map[String,A]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hGetAll</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.HashesCommands.hGetAll.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.async.HashesCommands.hGetAll.A">A</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns all the fields and values in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the fields and values in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>key-value pairs stored in hash with key, or <code>None</code> when hash is empty or key does not
exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hIncrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hIncrBy(key:String)(field:String,count:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="hIncrBy(String)(String,Long)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hIncrBy</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Increments the integer value of a hash field by the given number.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a hash field by the given number.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value at field after the increment operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the field does not hold an integer value or if the value stored at key is not of
type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, a new key holding a hash is created. If field does not exist the
value is set to 0 before the operation is performed.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hIncrByFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hIncrByFloat(key:String)(field:String,count:Double)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Double]"></a>
      <a id="hIncrByFloat(String)(String,Double)(CommandOptions):Future[Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hIncrByFloat</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Increments the float value of a hash field by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the float value of a hash field by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value at field after the increment operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the field does not hold a floating point value or if the value stored at key is
not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, a new key holding a hash is created. If field does not exist the
value is set to 0 before the operation is performed.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hKeys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hKeys(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Set[String]]"></a>
      <a id="hKeys(String)(CommandOptions):Future[Set[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hKeys</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns all the fields in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the fields in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>set of field names or the empty set if the hash is empty or the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hLen(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="hLen(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hLen</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the number of fields contained in the hash stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of fields contained in the hash stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>number of fields in the hash, or 0 if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hSet(key:String)(field:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="hSet(String)(String,Any)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hSet</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the string value of a hash field.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a hash field.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set</p></dd><dt>returns</dt><dd class="cmt"><p>true if field is a new field in the hash and value was set, false if field already
exists and the value was updated</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the field already exists in the hash, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hSetNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hSetNX(key:String)(field:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="hSetNX(String)(String,Any)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hSetNX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the value of a hash field, only if the field does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of a hash field, only if the field does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to set</p></dd><dt>returns</dt><dd class="cmt"><p>true if field is a new field in the hash and value was set, false if field already
exists and no operation was performed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hVals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hVals[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[List[A]]"></a>
      <a id="hVals[A](String)(CommandOptions,Parser[A]):Future[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hVals</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.HashesCommands.hVals.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scredis.commands.async.HashesCommands.hVals.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns all the values in a hash.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the values in a hash.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt>returns</dt><dd class="cmt"><p>list of values, or the empty if hash is empty or key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd></dl></div>
    </li><li name="scredis.QueuingClient#handleException" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="handleException(e:Throwable):Unit"></a>
      <a id="handleException(Throwable):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleException</span><span class="params">(<span name="e">e: <span class="extype" name="scala.Throwable">Throwable</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hmGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hmGet[A](key:String)(field:String,fields:String*)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[List[Option[A]]]"></a>
      <a id="hmGet[A](String)(String,String*)(CommandOptions,Parser[A]):Future[List[Option[A]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hmGet</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fields">fields: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.HashesCommands.hmGet.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.HashesCommands.hmGet.A">A</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the values associated to the specified hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the values associated to the specified hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to retrieve</p></dd><dt class="param">fields</dt><dd class="cmt"><p>additional field names to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>list of value(s) associated to the specified field names</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>For every field that does not exist, <code>None</code> is returned.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hmGetAsMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hmGetAsMap[A](key:String)(field:String,fields:String*)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Map[String,A]]"></a>
      <a id="hmGetAsMap[A](String)(String,String*)(CommandOptions,Parser[A]):Future[Map[String,A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hmGetAsMap</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="field">field: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fields">fields: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.HashesCommands.hmGetAsMap.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.async.HashesCommands.hmGetAsMap.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a <code>Map</code> containing field-value pairs associated to the specified hash fields.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Map</code> containing field-value pairs associated to the specified hash fields.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">field</dt><dd class="cmt"><p>field name to retrieve</p></dd><dt class="param">fields</dt><dd class="cmt"><p>additional field names to retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>field-value pairs associated to the specified field names</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Every non-existent field gets removed from the resulting <code>Map</code>.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hmSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hmSet(key:String)(fieldValuePair:(String,Any),fieldValuePairs:(String,Any)*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="hmSet(String)((String,Any),(String,Any)*)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hmSet</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="fieldValuePair">fieldValuePair: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>)</span>, <span name="fieldValuePairs">fieldValuePairs: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>)*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets multiple hash fields to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Sets multiple hash fields to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fieldValuePair</dt><dd class="cmt"><p>field-value pair to be set</p></dd><dt class="param">fieldValuePairs</dt><dd class="cmt"><p>additional field-value pairs to be set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This command overwrites any existing fields in the hash. If key does not exist, a new
key holding a hash is created
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.HashesCommands#hmSetFromMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hmSetFromMap(key:String,fieldValueMap:Map[String,Any])(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="hmSetFromMap(String,Map[String,Any])(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hmSetFromMap</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="fieldValueMap">fieldValueMap: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets multiple hash fields to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Sets multiple hash fields to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>hash key</p></dd><dt class="param">fieldValueMap</dt><dd class="cmt"><p>field-value pairs to set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if fieldValueMap is empty or the value stored at key is not of type hash
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This command overwrites any existing fields in the hash. If key does not exist, a new
key holding a hash is created
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#incr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="incr(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="incr(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">incr</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Increments the integer value of a key by one.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a key by one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the increment</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type or contains a string that cannot be
represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#incrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="incrBy(key:String,count:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="incrBy(String,Long)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">incrBy</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Increments the integer value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the integer value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type or contains
a string that cannot be represented as integer
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#incrByFloat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="incrByFloat(key:String,count:Double)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Double]"></a>
      <a id="incrByFloat(String,Double)(CommandOptions):Future[Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">incrByFloat</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Increment the float value of a key by the given amount.</p><div class="fullcomment"><div class="comment cmt"><p>Increment the float value of a key by the given amount.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the key to increment</p></dd><dt class="param">count</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the value of key after the decrement</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type, the current key content or the
specified increment are not parseable as a double precision floating point number
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the key does not exist, it is set to 0 before performing the operation.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#info" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="info()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Map[String,String]]"></a>
      <a id="info()(CommandOptions):Future[Map[String,String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">info</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets information and statistics about the server.</p><div class="fullcomment"><div class="comment cmt"><p>Gets information and statistics about the server.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>map of field -&gt; value pairs
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#infoBySection" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="infoBySection(section:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Map[String,String]]"></a>
      <a id="infoBySection(String)(CommandOptions):Future[Map[String,String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">infoBySection</span><span class="params">(<span name="section">section: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;default&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets information and statistics about the server.</p><div class="fullcomment"><div class="comment cmt"><p>Gets information and statistics about the server.
</p></div><dl class="paramcmts block"><dt class="param">section</dt><dd class="cmt"><p>name of the section for which data should be retrieved</p></dd><dt>returns</dt><dd class="cmt"><p>map of field -&gt; value pairs that match the specified section, or an empty map
if the section does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#infoBySectionRaw" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="infoBySectionRaw(section:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[String]"></a>
      <a id="infoBySectionRaw(String)(CommandOptions):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">infoBySectionRaw</span><span class="params">(<span name="section">section: <span class="extype" name="scala.Predef.String">String</span> = <span class="symbol">&quot;default&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets information and statistics about the server.</p><div class="fullcomment"><div class="comment cmt"><p>Gets information and statistics about the server.
</p></div><dl class="paramcmts block"><dt class="param">section</dt><dd class="cmt"><p>name of the section for which data should be retrieved</p></dd><dt>returns</dt><dd class="cmt"><p>raw string containing lines of field:value pairs that match the specified section,
as returned by Redis, or an empty string if the section does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#infoRaw" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="infoRaw()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[String]"></a>
      <a id="infoRaw()(CommandOptions):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">infoRaw</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets information and statistics about the server.</p><div class="fullcomment"><div class="comment cmt"><p>Gets information and statistics about the server.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>raw string containing lines of field:value pairs as returned by Redis
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.QueuingClient#isClosed" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isClosed:Boolean"></a>
      <a id="isClosed:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isClosed</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns whether this <code>QueuingClient</code> has been used already</p><div class="fullcomment"><div class="comment cmt"><p>Returns whether this <code>QueuingClient</code> has been used already</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if this <code>QueuingClient</code> has been used already, <code>false</code> otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#keys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="keys(pattern:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Set[String]]"></a>
      <a id="keys(String)(CommandOptions):Future[Set[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">keys</span><span class="params">(<span name="pattern">pattern: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Finds all keys matching the given pattern.</p><div class="fullcomment"><div class="comment cmt"><p>Finds all keys matching the given pattern.
</p></div><dl class="paramcmts block"><dt class="param">pattern</dt><dd class="cmt"><p>pattern to search for</p></dd><dt>returns</dt><dd class="cmt"><p>the matched keys, or the empty set if no keys match the given pattern
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lIndex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lIndex[A](key:String,index:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="lIndex[A](String,Long)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lIndex</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="index">index: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.lIndex.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.lIndex.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an element from a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an element from a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>zero-based position in the list</p></dd><dt>returns</dt><dd class="cmt"><p>the requested element, or <code>None</code> when index is out of range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The index is zero-based, so 0 means the first element, 1 the second element and so on.
Negative indices can be used to designate elements starting at the tail of the list.
Here, -1 means the last element, -2 means the penultimate and so forth.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lInsert" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lInsert(key:String,pivot:String,value:Any,after:Boolean)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="lInsert(String,String,Any,Boolean)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lInsert</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="pivot">pivot: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="after">after: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">true</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts an element before or after another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element before or after another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt class="param">after</dt><dd class="cmt"><p>when true, inserts the element after the pivot, when false the element is inserted
before the pivot (default is true, i.e. after)</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lInsertAfter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lInsertAfter(key:String,pivot:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="lInsertAfter(String,String,Any)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lInsertAfter</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="pivot">pivot: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts an element after another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element after another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lInsertBefore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lInsertBefore(key:String,pivot:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="lInsertBefore(String,String,Any)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lInsertBefore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="pivot">pivot: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts an element before another element in a list.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts an element before another element in a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">pivot</dt><dd class="cmt"><p>value after/before which the element should be inserted</p></dd><dt class="param">value</dt><dd class="cmt"><p>element to be inserted</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the insert operation, or None if the index is out of range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lLen(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lLen(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lLen</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the length of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list at key, or 0 if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPop[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="lPop[A](String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPop</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.lPop.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.lPop.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes and returns the first element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the first element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPush(key:String,value:Any,values:Any*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lPush(String,Any,Any*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPush</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="values">values: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Prepends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt class="param">values</dt><dd class="cmt"><p>additional values to prepend (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lPushX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lPushX(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lPushX(String,Any)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lPushX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Prepends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Prepends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lRange[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[List[A]]"></a>
      <a id="lRange[A](String,Long,Long)(CommandOptions,Parser[A]):Future[List[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lRange</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.lRange.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scredis.commands.async.ListsCommands.lRange.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of elements from a list.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of elements from a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>list of elements in the specified range, or the empty list if there are no such
elements or if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The offsets start and end are zero-based indexes, with 0 being the first element of the
list (the head of the list), 1 being the next element and so on. These offsets can also be
negative numbers indicating offsets starting at the end of the list. For example, -1 is the
last element of the list, -2 the penultimate, and so on. Both offsets are inclusive, i.e.
LRANGE key 0 10 will return 11 elements (if they exist).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lRem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lRem(key:String,value:Any,count:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lRem(String,Any,Long)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lRem</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="count">count: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes the first count occurrences of elements equal to value from the list stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the first count occurrences of elements equal to value from the list stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be removed from the list</p></dd><dt class="param">count</dt><dd class="cmt"><p>indicates the number of found values that should be removed, see above note</p></dd><dt>returns</dt><dd class="cmt"><p>the number of removed elements</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The count argument influences the operation in the following ways:</p><pre>count &gt; <span class="num">0</span>: Remove elements equal to value moving from head to tail.
count &lt; <span class="num">0</span>: Remove elements equal to value moving from tail to head.
count = <span class="num">0</span>: Remove all elements equal to value.</pre></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lSet(key:String,index:Long,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="lSet(String,Long,Any)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lSet</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="index">index: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the value of an element in a list by its index.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of an element in a list by its index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">index</dt><dd class="cmt"><p>position of the element to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be set at index</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if index is out of range or if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#lTrim" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lTrim(key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="lTrim(String,Long,Long)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lTrim</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Trims a list to the specified range.</p><div class="fullcomment"><div class="comment cmt"><p>Trims a list to the specified range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Out of range indexes will not produce an error: if start is larger than the end of the
list, or start &gt; end, the result will be an empty list (which causes key to be removed). If
end is larger than the end of the list, Redis will treat it like the last element of the list.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#lastSave" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lastSave()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="lastSave()(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lastSave</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets the UNIX timestamp of the last successful save to disk.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the UNIX timestamp of the last successful save to disk.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>UNIX timestamp
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#mGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mGet[A](key:String,keys:String*)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[List[Option[A]]]"></a>
      <a id="mGet[A](String,String*)(CommandOptions,Parser[A]):Future[List[Option[A]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mGet</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.StringsCommands.mGet.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.StringsCommands.mGet.A">A</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the values of all specified keys.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the values of all specified keys.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys</p></dd><dt>returns</dt><dd class="cmt"><p>list of value(s) stored at the specified key(s)
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>For every key that does not hold a string value or does not exist, <code>None</code> is returned.
Because of this, the operation never fails.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#mGetAsMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mGetAsMap[A](key:String,keys:String*)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Map[String,A]]"></a>
      <a id="mGetAsMap[A](String,String*)(CommandOptions,Parser[A]):Future[Map[String,A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mGetAsMap</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.StringsCommands.mGetAsMap.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scredis.commands.async.StringsCommands.mGetAsMap.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a <code>Map</code> containing the specified key(s) paired to their respective value(s).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Map</code> containing the specified key(s) paired to their respective value(s).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys</p></dd><dt>returns</dt><dd class="cmt"><p>map of key-value pairs
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>Every key that does not hold a string value or does not exist will be removed from the
resulting <code>Map</code>.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#mSet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mSet(keyValuePair:(String,Any),keyValuePairs:(String,Any)*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="mSet((String,Any),(String,Any)*)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mSet</span><span class="params">(<span name="keyValuePair">keyValuePair: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>)</span>, <span name="keyValuePairs">keyValuePairs: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>)*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically sets multiple keys to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">keyValuePair</dt><dd class="cmt"><p>key-value pair to be set</p></dd><dt class="param">keyValuePairs</dt><dd class="cmt"><p>additional key-value pairs to be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.1
</p></dd><dt>Note</dt><dd><span class="cmt"><p>MSET replaces existing values with new values, just as regular SET.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#mSetFromMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mSetFromMap(keyValueMap:Map[String,Any])(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="mSetFromMap(Map[String,Any])(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mSetFromMap</span><span class="params">(<span name="keyValueMap">keyValueMap: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically sets multiple keys to multiple values.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values.
</p></div><dl class="paramcmts block"><dt class="param">keyValueMap</dt><dd class="cmt"><p>key-value pairs to be set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.1
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the provided keyValueMap is empty
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>MSET replaces existing values with new values, just as regular SET.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#mSetNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mSetNX(keyValuePair:(String,Any),keyValuePairs:(String,Any)*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="mSetNX((String,Any),(String,Any)*)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mSetNX</span><span class="params">(<span name="keyValuePair">keyValuePair: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>)</span>, <span name="keyValuePairs">keyValuePairs: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>)*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically sets multiple keys to multiple values, only if none of the keys exist.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values, only if none of the keys exist.
</p></div><dl class="paramcmts block"><dt class="param">keyValuePair</dt><dd class="cmt"><p>key-value pair to be set</p></dd><dt class="param">keyValuePairs</dt><dd class="cmt"><p>additional key-value pairs to be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.1
</p></dd><dt>Note</dt><dd><span class="cmt"><p>MSETNX will not perform any operation at all even if just a single key already exists.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#mSetNXFromMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mSetNXFromMap(keyValueMap:Map[String,Any])(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="mSetNXFromMap(Map[String,Any])(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mSetNXFromMap</span><span class="params">(<span name="keyValueMap">keyValueMap: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically sets multiple keys to multiple values, only if none of the keys exist.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically sets multiple keys to multiple values, only if none of the keys exist.
</p></div><dl class="paramcmts block"><dt class="param">keyValueMap</dt><dd class="cmt"><p>key-value pairs to be set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.1
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the provided keyValueMap is empty
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>MSETNX will not perform any operation at all even if just a single key already exists.
</p></span></dd></dl></div>
    </li><li name="scredis.PipelineClient#methodName" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="methodName:String"></a>
      <a id="methodName:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">methodName</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="" class="extype" name="scredis.PipelineClient">PipelineClient</a> → <a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#migrate" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="migrate(key:String,host:String,port:Int,database:Int,timeout:scala.concurrent.duration.Duration,copy:Boolean,replace:Boolean)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="migrate(String,String,Int,Int,Duration,Boolean,Boolean)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">migrate</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="host">host: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="port">port: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">6379</span></span>, <span name="database">database: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">0</span></span>, <span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span> = <span class="symbol">2 seconds</span></span>, <span name="copy">copy: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="replace">replace: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically transfers a key from a Redis instance to another one.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically transfers a key from a Redis instance to another one.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to transfer</p></dd><dt class="param">host</dt><dd class="cmt"><p>destination host</p></dd><dt class="param">port</dt><dd class="cmt"><p>destination port</p></dd><dt class="param">database</dt><dd class="cmt"><p>destination database</p></dd><dt class="param">timeout</dt><dd class="cmt"><p>timeout duration</p></dd><dt class="param">copy</dt><dd class="cmt"><p>if true, do not remove the key from the local instance</p></dd><dt class="param">replace</dt><dd class="cmt"><p>if true, replace existing key on the remote instance</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if an error occurs
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#move" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="move(key:String,database:Int)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="move(String,Int)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">move</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="database">database: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Moves a key to another database.</p><div class="fullcomment"><div class="comment cmt"><p>Moves a key to another database.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to move</p></dd><dt class="param">database</dt><dd class="cmt"><p>destination database</p></dd><dt>returns</dt><dd class="cmt"><p>true if key was moved, false otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.PipelineClient#name" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="name:String"></a>
      <a id="name:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">name</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="" class="extype" name="scredis.PipelineClient">PipelineClient</a> → <a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#pExpire" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pExpire(key:String,ttlMillis:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="pExpire(String,Long)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pExpire</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="ttlMillis">ttlMillis: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets a key's time to live in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets a key's time to live in milliseconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">ttlMillis</dt><dd class="cmt"><p>time-to-live in milliseconds</p></dd><dt>returns</dt><dd class="cmt"><p>true if the ttl was set, false if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#pExpireAt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pExpireAt(key:String,timestampMillis:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="pExpireAt(String,Long)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pExpireAt</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="timestampMillis">timestampMillis: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the expiration for a key as a UNIX timestamp specified in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the expiration for a key as a UNIX timestamp specified in milliseconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to expire</p></dd><dt class="param">timestampMillis</dt><dd class="cmt"><p>UNIX milliseconds-timestamp at which the key should expire</p></dd><dt>returns</dt><dd class="cmt"><p>true if the ttl was set, false if key does not exist or
the timeout could not be set
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#pSetEX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pSetEX(key:String,value:Any,ttlMillis:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="pSetEX(String,Any,Long)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pSetEX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="ttlMillis">ttlMillis: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the value and expiration in milliseconds of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value and expiration in milliseconds of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlMillis</dt><dd class="cmt"><p>time-to-live in milliseconds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#pTtl" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pTtl(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="pTtl(String)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pTtl</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets the time to live for a key in milliseconds.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the time to live for a key in milliseconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to persist</p></dd><dt>returns</dt><dd class="cmt"><p>time-to-live in milliseconds for specified key, or <code>None</code> if key does not exist or does
not have a ttl
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#persist" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="persist(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="persist(String)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">persist</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes the expiration from a key.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the expiration from a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to persist</p></dd><dt>returns</dt><dd class="cmt"><p>true if key was persisted, false if key does not exist or does not have an
associated timeout
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ConnectionCommands#ping" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ping()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[String]"></a>
      <a id="ping()(CommandOptions):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ping</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Pings the server.</p><div class="fullcomment"><div class="comment cmt"><p>Pings the server. This command is often used to test if a connection is still alive,
or to measure latency.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>PONG
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ConnectionCommands.html" class="extype" name="scredis.commands.async.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.PubSubCommands#publish" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="publish(channel:String,message:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="publish(String,String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">publish</span><span class="params">(<span name="channel">channel: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="message">message: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Publishes a message to a channel.</p><div class="fullcomment"><div class="comment cmt"><p>Publishes a message to a channel.
</p></div><dl class="paramcmts block"><dt class="param">channel</dt><dd class="cmt"><p>the name of the channel</p></dd><dt class="param">message</dt><dd class="cmt"><p>the message payload</p></dd><dt>returns</dt><dd class="cmt"><p>the number of clients that received the message
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/PubSubCommands.html" class="extype" name="scredis.commands.async.PubSubCommands">PubSubCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd></dl></div>
    </li><li name="scredis.QueuingClient#queued" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="queued:scala.collection.mutable.ListBuffer[(Seq[Array[Byte]],(Char,Array[Byte])=&gt;Any)]"></a>
      <a id="queued:ListBuffer[(Seq[Array[Byte]],(Char,Array[Byte])⇒Any)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">queued</span><span class="result">: <span class="extype" name="scala.collection.mutable.ListBuffer">ListBuffer</span>[(<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]], (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scala.Any">Any</span>)]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPop[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="rPop[A](String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPop</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.rPop.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.rPop.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes and returns the last element of a list.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns the last element of a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPopLPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPopLPush[A](sourceKey:String,destKey:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="rPopLPush[A](String,String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPopLPush</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="sourceKey">sourceKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.ListsCommands.rPopLPush.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.ListsCommands.rPopLPush.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes the last element in a list, appends it to another list and returns it.</p><div class="fullcomment"><div class="comment cmt"><p>Removes the last element in a list, appends it to another list and returns it.
</p></div><dl class="paramcmts block"><dt class="param">sourceKey</dt><dd class="cmt"><p>key of list to be pop from</p></dd><dt class="param">destKey</dt><dd class="cmt"><p>key of list to be push to</p></dd><dt>returns</dt><dd class="cmt"><p>the popped element, or <code>None</code> if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPush(key:String,value:Any,values:Any*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="rPush(String,Any,Any*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPush</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="values">values: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Appends one or multiple values to a list.</p><div class="fullcomment"><div class="comment cmt"><p>Appends one or multiple values to a list.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt class="param">values</dt><dd class="cmt"><p>additional values to prepend (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operations</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If key does not exist, it is created as empty list before performing the push operation.
Redis versions older than 2.4 can only push one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ListsCommands#rPushX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rPushX(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="rPushX(String,Any)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rPushX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Appends a value to a list, only if the list exists.</p><div class="fullcomment"><div class="comment cmt"><p>Appends a value to a list, only if the list exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>list key</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to prepend</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the list after the push operation</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a non-list value
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#randomKey" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="randomKey()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[String]]"></a>
      <a id="randomKey()(CommandOptions):Future[Option[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">randomKey</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a random key from the keyspace.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random key from the keyspace.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the random key or <code>None</code> when the database is empty
associated timeout
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#rename" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rename(key:String,newKey:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="rename(String,String)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rename</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="newKey">newKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Renames a key.</p><div class="fullcomment"><div class="comment cmt"><p>Renames a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>source key</p></dd><dt class="param">newKey</dt><dd class="cmt"><p>destination key</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the source and destination keys are the same, or when key
does not exist
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>if newKey already exists, it is overwritten</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#renameNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="renameNX(key:String,newKey:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="renameNX(String,String)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">renameNX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="newKey">newKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Renames a key, only if the new key does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Renames a key, only if the new key does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>source key</p></dd><dt class="param">newKey</dt><dd class="cmt"><p>destination key</p></dd><dt>returns</dt><dd class="cmt"><p>true if key was renamed to newKey, false if newKey already exists</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the source and destination keys are the same, or when key does not exist
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#restore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restore(key:String,serializedValue:Array[Byte],ttl:Option[scala.concurrent.duration.FiniteDuration])(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="restore(String,Array[Byte],Option[FiniteDuration])(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">restore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="serializedValue">serializedValue: <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]</span>, <span name="ttl">ttl: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a key using the provided serialized value, previously obtained using DUMP.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a key using the provided serialized value, previously obtained using DUMP.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>destination key</p></dd><dt class="param">serializedValue</dt><dd class="cmt"><p>serialized value, previously obtained using DUMP</p></dd><dt class="param">ttl</dt><dd class="cmt"><p>optional time-to-live duration of newly created key (expire)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value could not be restored
</p></span></dd></dl></div>
    </li><li name="scredis.QueuingClient#run" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="run()(implicitopts:scredis.CommandOptions):IndexedSeq[scala.util.Try[Any]]"></a>
      <a id="run()(CommandOptions):IndexedSeq[Try[Any]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">run</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a></span>)</span><span class="result">: <span class="extype" name="scala.IndexedSeq">IndexedSeq</span>[<span class="extype" name="scala.util.Try">Try</span>[<span class="extype" name="scala.Any">Any</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scredis.PipelineClient#runImpl" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="runImpl(commands:List[(Seq[Array[Byte]],(Char,Array[Byte])=&gt;Any)]):IndexedSeq[scala.util.Try[Any]]"></a>
      <a id="runImpl(List[(Seq[Array[Byte]],(Char,Array[Byte])⇒Any)]):IndexedSeq[Try[Any]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">runImpl</span><span class="params">(<span name="commands">commands: <span class="extype" name="scala.List">List</span>[(<span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]], (<span class="extype" name="scala.Char">Char</span>, <span class="extype" name="scala.Array">Array</span>[<span class="extype" name="scala.Byte">Byte</span>]) ⇒ <span class="extype" name="scala.Any">Any</span>)]</span>)</span><span class="result">: <span class="extype" name="scala.IndexedSeq">IndexedSeq</span>[<span class="extype" name="scala.util.Try">Try</span>[<span class="extype" name="scala.Any">Any</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="" class="extype" name="scredis.PipelineClient">PipelineClient</a> → <a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sAdd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sAdd(key:String,member:Any,members:Any*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="sAdd(String,Any,Any*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sAdd</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>, <span name="members">members: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Adds one or more members to a set.</p><div class="fullcomment"><div class="comment cmt"><p>Adds one or more members to a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to add</p></dd><dt class="param">members</dt><dd class="cmt"><p>additional values to add (only works for Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements that were added to the set, not including all the elements
already present into the set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sCard" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sCard(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="sCard(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sCard</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the number of members in a set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of members in a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality (number of elements) of the set, or 0 if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sDiff" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sDiff[A](firstKey:String,key:String,keys:String*)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Set[A]]"></a>
      <a id="sDiff[A](String,String,String*)(CommandOptions,Parser[A]):Future[Set[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sDiff</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="firstKey">firstKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SetsCommands.sDiff.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.async.SetsCommands.sDiff.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the set resulting from the difference between the first set and all the successive
sets.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the set resulting from the difference between the first set and all the successive
sets.
</p></div><dl class="paramcmts block"><dt class="param">firstKey</dt><dd class="cmt"><p>key of first set</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of set to be substracted from first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys of sets to be substracted from first set</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if firstKey does not
exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if some keys contain a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sDiffStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sDiffStore(destKey:String)(key:String,keys:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="sDiffStore(String)(String,String*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sDiffStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Stores the set resulting from the difference between the first set and all the successive sets.</p><div class="fullcomment"><div class="comment cmt"><p>Stores the set resulting from the difference between the first set and all the successive sets.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be substracted from first set, if empty, first set is simply
copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if some keys contain a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sInter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sInter[A](firstKey:String,key:String,keys:String*)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Set[A]]"></a>
      <a id="sInter[A](String,String,String*)(CommandOptions,Parser[A]):Future[Set[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sInter</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="firstKey">firstKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SetsCommands.sInter.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.async.SetsCommands.sInter.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Intersects multiple sets.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sets.
</p></div><dl class="paramcmts block"><dt class="param">firstKey</dt><dd class="cmt"><p>key of first set</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of set to be intersected with first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys of sets to be intersected with all sets</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if firstKey does not</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if some keys contain a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sInterStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sInterStore(destKey:String)(key:String,keys:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="sInterStore(String)(String,String*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sInterStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Intersects multiple sets and stores the resulting set in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sets and stores the resulting set in a key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be intersected with all sets, if empty, first set is simply
copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if some keys contain a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sIsMember" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sIsMember(key:String,member:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="sIsMember(String,Any)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sIsMember</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Determines if a given value is a member of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Determines if a given value is a member of a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to be tested</p></dd><dt>returns</dt><dd class="cmt"><p>true if the provided value is a member of the set stored at key.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sMembers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sMembers[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Set[String]]"></a>
      <a id="sMembers[A](String)(CommandOptions,Parser[A]):Future[Set[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sMembers</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SetsCommands.sMembers.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns all the members of a set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns all the members of a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>set stored at key, or the empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sMove" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sMove(sourceKey:String,member:Any)(destKey:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="sMove(String,Any)(String)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sMove</span><span class="params">(<span name="sourceKey">sourceKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Moves a member from one set to another.</p><div class="fullcomment"><div class="comment cmt"><p>Moves a member from one set to another.
</p></div><dl class="paramcmts block"><dt class="param">sourceKey</dt><dd class="cmt"><p>key of source set</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to be moved from source set to destination set</p></dd><dt>returns</dt><dd class="cmt"><p>true if the member was moved, false if the element is not a member of source set and
no operation was performed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if sourceKey or destKey contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sPop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sPop[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="sPop[A](String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sPop</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SetsCommands.sPop.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.SetsCommands.sPop.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes and returns a random member from a set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes and returns a random member from a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>random member, or <code>None</code> if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>This operation is similar to SRANDMEMBER, that returns a random element from a set but
does not remove it.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sRandMember" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sRandMember[A](key:String)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Option[A]]"></a>
      <a id="sRandMember[A](String)(CommandOptions,Parser[A]):Future[Option[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sRandMember</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SetsCommands.sRandMember.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.SetsCommands.sRandMember.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a random member from a set (without removing it).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random member from a set (without removing it).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt>returns</dt><dd class="cmt"><p>random member, or <code>None</code> if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sRandMembers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sRandMembers[A](key:String,count:Int)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Set[A]]"></a>
      <a id="sRandMembers[A](String,Int)(CommandOptions,Parser[A]):Future[Set[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sRandMembers</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="count">count: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SetsCommands.sRandMembers.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.async.SetsCommands.sRandMembers.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a random member from a set (without removing it).</p><div class="fullcomment"><div class="comment cmt"><p>Returns a random member from a set (without removing it).
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">count</dt><dd class="cmt"><p>number of member to randomly retrieve</p></dd><dt>returns</dt><dd class="cmt"><p>set of random members, or the empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sRem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sRem(key:String,member:Any,members:Any*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="sRem(String,Any,Any*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sRem</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>, <span name="members">members: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes one or more members from a set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes one or more members from a set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>value to remove from set</p></dd><dt class="param">members</dt><dd class="cmt"><p>additional values to remove from set (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members that were removed from the set, not including non-existing
members</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Redis versions older than 2.4 can only remove one member per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sUnion" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sUnion[A](firstKey:String,key:String,keys:String*)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[Set[A]]"></a>
      <a id="sUnion[A](String,String,String*)(CommandOptions,Parser[A]):Future[Set[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sUnion</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="firstKey">firstKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SetsCommands.sUnion.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.Set">Set</span>[<span class="extype" name="scredis.commands.async.SetsCommands.sUnion.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the union of multiple sets.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sets.
</p></div><dl class="paramcmts block"><dt class="param">firstKey</dt><dd class="cmt"><p>key of first set</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of set to be intersected with first set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys of sets to be included in the union computation</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting set, or the empty set if firstKey does not</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if some keys contain a value that is not a set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SetsCommands#sUnionStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sUnionStore(destKey:String)(key:String,keys:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="sUnionStore(String)(String,String*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sUnionStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the union of multiple sets and stores the resulting set in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sets and stores the resulting set in a key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>key where to store the resulting set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>keys of sets to be included in the union computation, if empty, first set is
simply copied to destKey</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting set</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if some keys contain a value that is not a set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If destKey already exists, it is overwritten.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#save" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="save()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="save()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">save</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Synchronously saves the dataset to disk.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronously saves the dataset to disk.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#scriptExists" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptExists(sha1:String,sha1s:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[IndexedSeq[Boolean]]"></a>
      <a id="scriptExists(String,String*)(CommandOptions):Future[IndexedSeq[Boolean]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptExists</span><span class="params">(<span name="sha1">sha1: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="sha1s">sha1s: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.IndexedSeq">IndexedSeq</span>[<span class="extype" name="scala.Boolean">Boolean</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Checks existence of scripts in the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Checks existence of scripts in the script cache.
</p></div><dl class="paramcmts block"><dt class="param">sha1</dt><dd class="cmt"><p>the SHA1 digest to check for</p></dd><dt class="param">sha1s</dt><dd class="cmt"><p>additional digests to check for</p></dd><dt>returns</dt><dd class="cmt"><p>indexed sequence of booleans where true means the script is in the cache
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#scriptFlush" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptFlush()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="scriptFlush()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptFlush</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes all the scripts from the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all the scripts from the script cache.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#scriptKill" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptKill()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="scriptKill()(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptKill</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Kills the currently executing Lua script, assuming no write operation was yet performed by
the script.</p><div class="fullcomment"><div class="comment cmt"><p>Kills the currently executing Lua script, assuming no write operation was yet performed by
the script.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If the script already performed write operations it can not be killed in this way
because it would violate Lua script atomicity contract. In such a case only SHUTDOWN NOSAVE
is able to kill the script, killing the Redis process in an hard way preventing it to persist
with half-written information.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ScriptingCommands#scriptLoad" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scriptLoad(script:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[String]"></a>
      <a id="scriptLoad(String)(CommandOptions):Future[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">scriptLoad</span><span class="params">(<span name="script">script: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads or stores the specified Lua script into the script cache.</p><div class="fullcomment"><div class="comment cmt"><p>Loads or stores the specified Lua script into the script cache.
</p></div><dl class="paramcmts block"><dt class="param">script</dt><dd class="cmt"><p>the script to be loaded into the cache</p></dd><dt>returns</dt><dd class="cmt"><p>the SHA1 digest of the stored script</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if a compilation error occurs
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The script is guaranteed to stay in the script cache forever (unless SCRIPT FLUSH
is called).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.ConnectionCommands#select" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="select(db:Int)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="select(Int)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">select</span><span class="params">(<span name="db">db: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Changes the selected database on the current client.</p><div class="fullcomment"><div class="comment cmt"><p>Changes the selected database on the current client.
</p></div><dl class="paramcmts block"><dt class="param">db</dt><dd class="cmt"><p>database index</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ConnectionCommands.html" class="extype" name="scredis.commands.async.ConnectionCommands">ConnectionCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the database index is invalid
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#set" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="set(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="set(String,Any)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">set</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the string value of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the string value of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#setBit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setBit(key:String,offset:Long,bit:Boolean)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="setBit(String,Long,Boolean)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setBit</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>, <span name="bit">bit: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets or clears the bit at offset in the string value stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets or clears the bit at offset in the string value stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key for which the bit should be set</p></dd><dt class="param">offset</dt><dd class="cmt"><p>position where the bit should be set</p></dd><dt class="param">bit</dt><dd class="cmt"><p>true sets the bit to 1, false sets it to 0</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>When key does not exist, a new string value is created. The string is grown to make sure
it can hold a bit at offset. When the string at key is grown, added bits are set to 0.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#setEX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setEX(key:String,value:Any,ttlSeconds:Int)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="setEX(String,Any,Int)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setEX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="ttlSeconds">ttlSeconds: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the value and expiration in seconds of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value and expiration in seconds of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttlSeconds</dt><dd class="cmt"><p>time-to-live in seconds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#setEXDuration" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setEXDuration(key:String,value:Any,ttl:scala.concurrent.duration.Duration)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Unit]"></a>
      <a id="setEXDuration(String,Any,Duration)(CommandOptions):Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setEXDuration</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>, <span name="ttl">ttl: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the value and expiration of a key.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value and expiration of a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt class="param">ttl</dt><dd class="cmt"><p>time-to-live
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>If key already holds a value, it is overwritten, regardless of its type.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#setNX" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setNX(key:String,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Boolean]"></a>
      <a id="setNX(String,Any)(CommandOptions):Future[Boolean]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setNX</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Boolean">Boolean</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the value of a key, only if the key does not exist.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of a key, only if the key does not exist.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key to set</p></dd><dt class="param">value</dt><dd class="cmt"><p>value to be stored at key</p></dd><dt>returns</dt><dd class="cmt"><p>true if the key was set, false otherwise
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#setRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="setRange(key:String,offset:Long,value:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="setRange(String,Long,Any)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setRange</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>, <span name="value">value: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Overwrites part of a string at key starting at the specified offset.</p><div class="fullcomment"><div class="comment cmt"><p>Overwrites part of a string at key starting at the specified offset.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key</p></dd><dt class="param">offset</dt><dd class="cmt"><p>position from which the string must be overwritten</p></dd><dt class="param">value</dt><dd class="cmt"><p>string value to be set at given offset</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string after it was modified by the command</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If the offset is larger than the current length of the string at key, the string is
padded with zero-bytes to make offset fit. Non-existing keys are considered as empty strings,
so this command will make sure it holds a string large enough to be able to set value at
offset.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#sort" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sort[A](key:String,by:Option[String],limit:Option[(Long,Long)],get:Traversable[String],desc:Boolean,alpha:Boolean)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[List[Option[A]]]"></a>
      <a id="sort[A](String,Option[String],Option[(Long,Long)],Traversable[String],Boolean,Boolean)(CommandOptions,Parser[A]):Future[List[Option[A]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sort</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="by">by: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="limit">limit: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>, <span name="get">get: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">Traversable()</span></span>, <span name="desc">desc: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="alpha">alpha: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.KeysCommands.sort.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scredis.commands.async.KeysCommands.sort.A">A</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sorts the elements of a list, set or sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Sorts the elements of a list, set or sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">by</dt><dd class="cmt"><p>optional pattern for sorting by external values, can also be &quot;nosort&quot; if
the sorting operation should be skipped (useful when only sorting to retrieve objects
with get). The * gets replaced by the values of the elements in the collection</p></dd><dt class="param">limit</dt><dd class="cmt"><p>optional pair of numbers (offset, count) where offset specified the number of
elements to skip and count specifies the number of elements to return starting from offset</p></dd><dt class="param">get</dt><dd class="cmt"><p>list of patterns for retrieving objects stored in external keys. The * gets
replaced by the values of the elements in the collection</p></dd><dt class="param">desc</dt><dd class="cmt"><p>indicates whether elements should be sorted descendingly</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>indicates whether elements should be sorted lexicographically</p></dd><dt>returns</dt><dd class="cmt"><p>the sorted list of elements, or the empty list if the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>whenever an error occurs
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#sortAndStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sortAndStore(key:String,targetKey:String,by:Option[String],limit:Option[(Long,Long)],get:Traversable[String],desc:Boolean,alpha:Boolean)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="sortAndStore(String,String,Option[String],Option[(Long,Long)],Traversable[String],Boolean,Boolean)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sortAndStore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="targetKey">targetKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="by">by: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">None</span></span>, <span name="limit">limit: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>, <span name="get">get: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Predef.String">String</span>] = <span class="symbol">Traversable()</span></span>, <span name="desc">desc: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="alpha">alpha: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sorts the elements of a list, set or sorted set and then store the result.</p><div class="fullcomment"><div class="comment cmt"><p>Sorts the elements of a list, set or sorted set and then store the result.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">targetKey</dt><dd class="cmt"><p>key of list, set or sorted set to be sorted</p></dd><dt class="param">by</dt><dd class="cmt"><p>optional pattern for sorting by external values, can also be &quot;nosort&quot; if
the sorting operation should be skipped (useful when only sorting to retrieve objects
with get). The * gets replaced by the values of the elements in the collection</p></dd><dt class="param">limit</dt><dd class="cmt"><p>optional pair of numbers (offset, count) where offset specified the
number of elements to skip and count specifies the number of elements to return starting
from offset</p></dd><dt class="param">get</dt><dd class="cmt"><p>list of patterns for retrieving objects stored in external keys. The * gets
replaced by the values of the elements in the collection</p></dd><dt class="param">desc</dt><dd class="cmt"><p>indicates whether elements should be sorted descendingly</p></dd><dt class="param">alpha</dt><dd class="cmt"><p>indicates whether elements should be sorted lexicographically</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the newly stored sorted collection</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>whenever an error occurs
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.StringsCommands#strLen" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="strLen(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="strLen(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">strLen</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the length of the string value stored in a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the length of the string value stored in a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>target key</p></dd><dt>returns</dt><dd class="cmt"><p>the length of the string stored at key, or 0 when the key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the key contains a value of the wrong type
</p></span></dd></dl></div>
    </li><li name="scredis.PipelineClient#sync" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="sync()(implicitopts:scredis.CommandOptions):IndexedSeq[scala.util.Try[Any]]"></a>
      <a id="sync()(CommandOptions):IndexedSeq[Try[Any]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">sync</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol"><span class="name"><a href="QueuingClient.html#DefaultCommandOptions:scredis.CommandOptions">DefaultCommandOptions</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.IndexedSeq">IndexedSeq</span>[<span class="extype" name="scala.util.Try">Try</span>[<span class="extype" name="scala.Any">Any</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Executes the pipeline and returns all results.</p><div class="fullcomment"><div class="comment cmt"><p>Executes the pipeline and returns all results.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an <code>IndexedSeq</code> containing the results of each command, in the order they were queued.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scredis.commands.async.ServerCommands#time" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="time()(implicitopts:scredis.CommandOptions):scala.concurrent.Future[(Long,Long)]"></a>
      <a id="time()(CommandOptions):Future[(Long,Long)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">time</span><span class="params">()</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the current server time.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the current server time.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>pair of longs containing (1) UNIX timestamp and (2) microseconds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#ttl" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ttl(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Int]]"></a>
      <a id="ttl(String)(CommandOptions):Future[Option[Int]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ttl</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Int">Int</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets the time to live for a key in seconds.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the time to live for a key in seconds.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to persist</p></dd><dt>returns</dt><dd class="cmt"><p>time-to-live in seconds for specified key, or <code>None</code> if key does not exist or does not
have a ttl
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#ttlDuration" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ttlDuration(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[scala.concurrent.duration.FiniteDuration]]"></a>
      <a id="ttlDuration(String)(CommandOptions):Future[Option[FiniteDuration]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ttlDuration</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.concurrent.duration.FiniteDuration">FiniteDuration</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Gets the time to live for a key.</p><div class="fullcomment"><div class="comment cmt"><p>Gets the time to live for a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key to persist</p></dd><dt>returns</dt><dd class="cmt"><p>time-to-live for specified key or <code>None</code> if key does not exist or does not have a ttl
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>2.6.0
</p></dd></dl></div>
    </li><li name="scredis.commands.async.KeysCommands#type" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="type(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[String]]"></a>
      <a id="type(String)(CommandOptions):Future[Option[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">type</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Determine the type stored at key.</p><div class="fullcomment"><div class="comment cmt"><p>Determine the type stored at key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>key for which the type should be returned</p></dd><dt>returns</dt><dd class="cmt"><p>type of key, or <code>None</code> if key does not exist
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Note</dt><dd><span class="cmt"><p>This method needs to be called as follows:</p><pre>client.`<span class="kw">type</span>`(key)</pre></span></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zAdd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zAdd(key:String,memberScorePair:(Any,Double),memberScorePairs:(Any,Double)*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zAdd(String,(Any,Double),(Any,Double)*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zAdd</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="memberScorePair">memberScorePair: (<span class="extype" name="scala.Any">Any</span>, <span class="extype" name="scala.Double">Double</span>)</span>, <span name="memberScorePairs">memberScorePairs: (<span class="extype" name="scala.Any">Any</span>, <span class="extype" name="scala.Double">Double</span>)*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Adds one or more members to a sorted set, or update its score if it already exists.</p><div class="fullcomment"><div class="comment cmt"><p>Adds one or more members to a sorted set, or update its score if it already exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">memberScorePair</dt><dd class="cmt"><p>member-score pair to be added</p></dd><dt class="param">memberScorePairs</dt><dd class="cmt"><p>additional member-score pairs to be added (adding several members at
once only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements added to the sorted sets, not including elements already
existing for which the score was updated</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If a specified member is already a member of the sorted set, the score is updated and
the element reinserted at the right position to ensure the correct ordering.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zAddFromMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zAddFromMap(key:String,memberScoreMap:Map[Any,Double])(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zAddFromMap(String,Map[Any,Double])(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zAddFromMap</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="memberScoreMap">memberScoreMap: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Any">Any</span>, <span class="extype" name="scala.Double">Double</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Adds one or more members to a sorted set, or update its score if it already exists.</p><div class="fullcomment"><div class="comment cmt"><p>Adds one or more members to a sorted set, or update its score if it already exists.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">memberScoreMap</dt><dd class="cmt"><p>member-score pairs to be added (adding several members at once only works
with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements added to the sorted sets, not including elements already
existing for which the score was updated</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if memberScoreMap is empty or key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>If a specified member is already a member of the sorted set, the score is updated and
the element reinserted at the right position to ensure the correct ordering.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zCard" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zCard(key:String)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zCard(String)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zCard</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the number of members in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of members in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt>returns</dt><dd class="cmt"><p>the cardinality (number of elements) of the sorted set, or 0 if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zCount" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zCount(key:String,min:scredis.Score,max:scredis.Score)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zCount(String,Score,Score)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zCount</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="max">max: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the number of elements of a sorted set belonging to a given score range.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the number of elements of a sorted set belonging to a given score range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the specified score range</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zIncrBy" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zIncrBy(key:String,member:Any,count:Double)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Double]"></a>
      <a id="zIncrBy(String,Any,Double)(CommandOptions):Future[Double]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zIncrBy</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>, <span name="count">count: <span class="extype" name="scala.Double">Double</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Double">Double</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Increments the score of a member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Increments the score of a member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>member whose score needs to be incremented</p></dd><dt class="param">count</dt><dd class="cmt"><p>the increment</p></dd><dt>returns</dt><dd class="cmt"><p>the new score of member</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zInterStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zInterStore(destKey:String,aggregate:scredis.Aggregate)(key:String,keys:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zInterStore(String,Aggregate)(String,String*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zInterStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="aggregate">aggregate: <a href="Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">Sum</a></span></span></span>)</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Intersects multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of first sorted set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys of sorted sets</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zInterStoreWeighted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zInterStoreWeighted(destKey:String,aggregate:scredis.Aggregate)(keyWeightPair:(String,Int),keyWeightPairs:(String,Int)*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zInterStoreWeighted(String,Aggregate)((String,Int),(String,Int)*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zInterStoreWeighted</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="aggregate">aggregate: <a href="Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">Sum</a></span></span></span>)</span><span class="params">(<span name="keyWeightPair">keyWeightPair: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Int">Int</span>)</span>, <span name="keyWeightPairs">keyWeightPairs: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Int">Int</span>)*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Intersects multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Intersects multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt class="param">keyWeightPair</dt><dd class="cmt"><p>first sorted set key to weight pair</p></dd><dt class="param">keyWeightPairs</dt><dd class="cmt"><p>additional sorted set key to weight pairs</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRange[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[A]]"></a>
      <a id="zRange[A](String,Long,Long)(CommandOptions,Parser[A]):Future[LinkedHashSet[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRange</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRange.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRange.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified range, or the empty set if
key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next
element and so on. They can also be negative numbers indicating offsets from the end of the
sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and
so on. Out of range indexes will not produce an error. If start is larger than the largest
index in the sorted set, or <code>start</code> &gt; <code>end</code>, an empty list is returned. If <code>end</code> is larger
than the end of the sorted set Redis will treat it like it is the last element of the
sorted set. The indexes are inclusive.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRangeByScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRangeByScore[A](key:String,min:scredis.Score,max:scredis.Score,limit:Option[(Long,Long)])(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[A]]"></a>
      <a id="zRangeByScore[A](String,Score,Score,Option[(Long,Long)])(CommandOptions,Parser[A]):Future[LinkedHashSet[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRangeByScore</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="max">max: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="limit">limit: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRangeByScore.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRangeByScore.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">limit</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements in the specified score range, or the empty set
if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The elements having the same score are returned in lexicographical order (this follows
from a property of the sorted set implementation in Redis and does not involve further
computation).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRangeByScoreWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRangeByScoreWithScores[A](key:String,min:scredis.Score,max:scredis.Score,limit:Option[(Long,Long)])(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[(A,Double)]]"></a>
      <a id="zRangeByScoreWithScores[A](String,Score,Score,Option[(Long,Long)])(CommandOptions,Parser[A]):Future[LinkedHashSet[(A,Double)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRangeByScoreWithScores</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="max">max: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="limit">limit: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRangeByScoreWithScores.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRangeByScoreWithScores.A">A</span>, <span class="extype" name="scala.Double">Double</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of members with associated scores in a sorted set, by score.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members with associated scores in a sorted set, by score.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">limit</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered element-score pairs in the specified score range, or
the empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>The elements having the same score are returned in lexicographical order (this follows
from a property of the sorted set implementation in Redis and does not involve further
computation).
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRangeWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRangeWithScores[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[(A,Double)]]"></a>
      <a id="zRangeWithScores[A](String,Long,Long)(CommandOptions,Parser[A]):Future[LinkedHashSet[(A,Double)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRangeWithScores</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRangeWithScores.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRangeWithScores.A">A</span>, <span class="extype" name="scala.Double">Double</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of members with associated scores in a sorted set, by index.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members with associated scores in a sorted set, by index.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of ascendingly ordered elements-score pairs in the specified range, or the
empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based indexes, where 0 is the first element, 1 is the next
element and so on. They can also be negative numbers indicating offsets from the end of the
sorted set, with -1 being the last element of the sorted set, -2 the penultimate element and
so on. Out of range indexes will not produce an error. If start is larger than the largest
index in the sorted set, or <code>start</code> &gt; <code>end</code>, an empty list is returned. If <code>end</code> is larger
than the end of the sorted set Redis will treat it like it is the last element of the
sorted set. The indexes are inclusive.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRank(key:String,member:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="zRank(String,Any)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRank</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Determines the index of a member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Determines the index of a member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the rank or index of the member, or <code>None</code> if the member is not in the set or the key
does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRem(key:String,member:Any,members:Any*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zRem(String,Any,Any*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRem</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>, <span name="members">members: <span class="extype" name="scala.Any">Any</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes one or more members from a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Removes one or more members from a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value to be removed</p></dd><dt class="param">members</dt><dd class="cmt"><p>additional values to be removed (only works with Redis &gt;= 2.4)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed from the sorted set, not including non existing members</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Redis versions older than 2.4 can only remove one value per call.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRemRangeByRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRemRangeByRank(key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zRemRangeByRank(String,Long,Long)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRemRangeByRank</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes all members in a sorted set within the given indexes.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given indexes.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>the start offset or index (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>the end offset or index (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both start and stop are zero-based inclusive indexes with 0 being the element with the
lowest score. These indexes can be negative numbers, where they indicate offsets starting at
the element with the highest score. For example: -1 is the element with the highest score, -2
the element with the second highest score and so forth.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRemRangeByScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRemRangeByScore(key:String,min:scredis.Score,max:scredis.Score)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zRemRangeByScore(String,Score,Score)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRemRangeByScore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="min">min: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="max">max: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Removes all members in a sorted set within the given scores range.</p><div class="fullcomment"><div class="comment cmt"><p>Removes all members in a sorted set within the given scores range.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt>returns</dt><dd class="cmt"><p>the number of members removed</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Since version 2.1.6, min and max can be exclusive, following the syntax of ZRANGEBYSCORE.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRevRange" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRange[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[A]]"></a>
      <a id="zRevRange[A](String,Long,Long)(CommandOptions,Parser[A]):Future[LinkedHashSet[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRange</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRange.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRange.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by index, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified range, or the empty set if
key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGE is similar to ZRANGE.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRevRangeByScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRangeByScore[A](key:String,max:scredis.Score,min:scredis.Score,limit:Option[(Long,Long)])(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[A]]"></a>
      <a id="zRevRangeByScore[A](String,Score,Score,Option[(Long,Long)])(CommandOptions,Parser[A]):Future[LinkedHashSet[A]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRangeByScore</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="max">max: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="min">min: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="limit">limit: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRangeByScore.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRangeByScore.A">A</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by score, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by score, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">limit</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified score range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGEBYSCORE is similar to ZRANGEBYSCORE.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRevRangeByScoreWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRangeByScoreWithScores[A](key:String,max:scredis.Score,min:scredis.Score,limit:Option[(Long,Long)])(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[(A,Double)]]"></a>
      <a id="zRevRangeByScoreWithScores[A](String,Score,Score,Option[(Long,Long)])(CommandOptions,Parser[A]):Future[LinkedHashSet[(A,Double)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRangeByScoreWithScores</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="max">max: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="min">min: <a href="Score.html" class="extype" name="scredis.Score">Score</a></span>, <span name="limit">limit: <span class="extype" name="scala.Option">Option</span>[(<span class="extype" name="scala.Long">Long</span>, <span class="extype" name="scala.Long">Long</span>)] = <span class="symbol">None</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRangeByScoreWithScores.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRangeByScoreWithScores.A">A</span>, <span class="extype" name="scala.Double">Double</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return a range of members with associated scores in a sorted set, by score, with scores
ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Return a range of members with associated scores in a sorted set, by score, with scores
ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">max</dt><dd class="cmt"><p>score upper bound</p></dd><dt class="param">min</dt><dd class="cmt"><p>score lower bound</p></dd><dt class="param">limit</dt><dd class="cmt"><p>optional offset and count pair used to limit the number of matching elements</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements in the specified score range, or the empty
set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGEBYSCORE is similar to ZRANGEBYSCORE.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRevRangeWithScores" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRangeWithScores[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[scredis.util.LinkedHashSet[(A,Double)]]"></a>
      <a id="zRevRangeWithScores[A](String,Long,Long)(CommandOptions,Parser[A]):Future[LinkedHashSet[(A,Double)]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRangeWithScores</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">0</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span> = <span class="symbol">1</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRangeWithScores.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="util/LinkedHashSet.html" class="extype" name="scredis.util.LinkedHashSet">LinkedHashSet</a>[(<span class="extype" name="scredis.commands.async.SortedSetsCommands.zRevRangeWithScores.A">A</span>, <span class="extype" name="scala.Double">Double</span>)]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a range of members in a sorted set, by index, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a range of members in a sorted set, by index, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">start</dt><dd class="cmt"><p>start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the set of descendingly ordered elements-score pairs in the specified range, or the
empty set if key does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Apart from the reversed ordering, ZREVRANGE is similar to ZRANGE.
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zRevRank" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zRevRank(key:String,member:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Long]]"></a>
      <a id="zRevRank(String,Any)(CommandOptions):Future[Option[Long]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zRevRank</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Long">Long</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Determine the index of a member in a sorted set, with scores ordered from high to low.</p><div class="fullcomment"><div class="comment cmt"><p>Determine the index of a member in a sorted set, with scores ordered from high to low.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the rank or index of the member, or <code>None</code> if the member is not in the set or the key
does not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zScore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zScore(key:String,member:Any)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Option[Double]]"></a>
      <a id="zScore(String,Any)(CommandOptions):Future[Option[Double]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zScore</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="member">member: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Double">Double</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the score associated with the given member in a sorted set.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the score associated with the given member in a sorted set.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">member</dt><dd class="cmt"><p>the value</p></dd><dt>returns</dt><dd class="cmt"><p>the score of member, or <code>None</code> if the latter is not in the sorted set or the key does
not exist</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>1.2.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zUnionStore" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zUnionStore(destKey:String,aggregate:scredis.Aggregate)(key:String,keys:String*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zUnionStore(String,Aggregate)(String,String*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zUnionStore</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="aggregate">aggregate: <a href="Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">Sum</a></span></span></span>)</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="keys">keys: <span class="extype" name="scala.Predef.String">String</span>*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt class="param">key</dt><dd class="cmt"><p>key of first sorted set</p></dd><dt class="param">keys</dt><dd class="cmt"><p>additional keys of sorted sets</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li><li name="scredis.commands.async.SortedSetsCommands#zUnionStoreWeighted" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="zUnionStoreWeighted(destKey:String,aggregate:scredis.Aggregate)(keyWeightPair:(String,Int),keyWeightPairs:(String,Int)*)(implicitopts:scredis.CommandOptions):scala.concurrent.Future[Long]"></a>
      <a id="zUnionStoreWeighted(String,Aggregate)((String,Int),(String,Int)*)(CommandOptions):Future[Long]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">zUnionStoreWeighted</span><span class="params">(<span name="destKey">destKey: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="aggregate">aggregate: <a href="Aggregate.html" class="extype" name="scredis.Aggregate">Aggregate</a> = <span class="symbol"><span class="name"><a href="package.html">Sum</a></span></span></span>)</span><span class="params">(<span name="keyWeightPair">keyWeightPair: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Int">Int</span>)</span>, <span name="keyWeightPairs">keyWeightPairs: (<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Int">Int</span>)*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the union of multiple sorted sets and stores the resulting sorted set in a new key.
</p></div><dl class="paramcmts block"><dt class="param">destKey</dt><dd class="cmt"><p>sorted set key</p></dd><dt class="param">aggregate</dt><dd class="cmt"><p>aggregation function (default is Sum)</p></dd><dt class="param">keyWeightPair</dt><dd class="cmt"><p>first sorted set key to weight pair</p></dd><dt class="param">keyWeightPairs</dt><dd class="cmt"><p>additional sorted set key to weight pairs</p></dd><dt>returns</dt><dd class="cmt"><p>the number of elements in the resulting sorted set stored at destKey</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></dd><dt>Since</dt><dd><p>2.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if key contains a value that is not a sorted set
</p></span></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="scredis.commands.async.StringsCommands#substr" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="substr[A](key:String,start:Long,end:Long)(implicitopts:scredis.CommandOptions,implicitparser:scredis.parsing.Parser[A]):scala.concurrent.Future[A]"></a>
      <a id="substr[A](String,Long,Long)(CommandOptions,Parser[A]):Future[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.0.1) SUBSTR has been renamed to GETRANGE in Redis versions &gt; 2.0.0">substr</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="key">key: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="start">start: <span class="extype" name="scala.Long">Long</span></span>, <span name="end">end: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="opts">opts: <a href="CommandOptions.html" class="extype" name="scredis.CommandOptions">CommandOptions</a> = <span class="symbol">DefaultCommandOptions</span></span>, <span name="parser">parser: <a href="parsing/Parser.html" class="extype" name="scredis.parsing.Parser">Parser</a>[<span class="extype" name="scredis.commands.async.StringsCommands.substr.A">A</span>] = <span class="symbol"><span class="name"><a href="package.html">StringParser</a></span></span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scredis.commands.async.StringsCommands.substr.A">A</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a substring of the string stored at a key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a substring of the string stored at a key.
</p></div><dl class="paramcmts block"><dt class="param">key</dt><dd class="cmt"><p>the target key</p></dd><dt class="param">start</dt><dd class="cmt"><p>the start offset (inclusive)</p></dd><dt class="param">end</dt><dd class="cmt"><p>the end offset (inclusive)</p></dd><dt>returns</dt><dd class="cmt"><p>the substring determined by the specified offsets</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.0.1)</i> SUBSTR has been renamed to GETRANGE in Redis versions &gt; 2.0.0</p></dd><dt>Since</dt><dd><p>1.0.0
</p></dd><dt>Exceptions thrown</dt><dd><span class="cmt">[[scredis.exceptions.RedisCommandException]]<p>if the value stored at key is not of type string
</p></span></dd><dt>Note</dt><dd><span class="cmt"><p>Both offsets are inclusive, i.e. [start, end]. The function handles out of range
requests by limiting the resulting range to the actual length of the string.
</p></span></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scredis.commands.async.PubSubCommands">
              <h3>Inherited from <a href="commands/async/PubSubCommands.html" class="extype" name="scredis.commands.async.PubSubCommands">PubSubCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.ScriptingCommands">
              <h3>Inherited from <a href="commands/async/ScriptingCommands.html" class="extype" name="scredis.commands.async.ScriptingCommands">ScriptingCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.SortedSetsCommands">
              <h3>Inherited from <a href="commands/async/SortedSetsCommands.html" class="extype" name="scredis.commands.async.SortedSetsCommands">SortedSetsCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.SetsCommands">
              <h3>Inherited from <a href="commands/async/SetsCommands.html" class="extype" name="scredis.commands.async.SetsCommands">SetsCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.ListsCommands">
              <h3>Inherited from <a href="commands/async/ListsCommands.html" class="extype" name="scredis.commands.async.ListsCommands">ListsCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.HashesCommands">
              <h3>Inherited from <a href="commands/async/HashesCommands.html" class="extype" name="scredis.commands.async.HashesCommands">HashesCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.StringsCommands">
              <h3>Inherited from <a href="commands/async/StringsCommands.html" class="extype" name="scredis.commands.async.StringsCommands">StringsCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.KeysCommands">
              <h3>Inherited from <a href="commands/async/KeysCommands.html" class="extype" name="scredis.commands.async.KeysCommands">KeysCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.ServerCommands">
              <h3>Inherited from <a href="commands/async/ServerCommands.html" class="extype" name="scredis.commands.async.ServerCommands">ServerCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.ConnectionCommands">
              <h3>Inherited from <a href="commands/async/ConnectionCommands.html" class="extype" name="scredis.commands.async.ConnectionCommands">ConnectionCommands</a></h3>
            </div><div class="parent" name="scredis.commands.async.Async">
              <h3>Inherited from <span class="extype" name="scredis.commands.async.Async">Async</span></h3>
            </div><div class="parent" name="scredis.QueuingClient">
              <h3>Inherited from <a href="QueuingClient.html" class="extype" name="scredis.QueuingClient">QueuingClient</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../lib/template.js"></script>
    </body>
      </html>